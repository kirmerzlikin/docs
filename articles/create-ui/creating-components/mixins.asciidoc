---
title: Using Vaadin Mixin Interfaces
order: 10
---

= Using Vaadin Mixin Interfaces

A "mixin" refers to a defined amount of functionality that can be added to a class.
Traditionally, Java didn't support this kind of multiple inheritance but, since Java 8, interfaces can also include default methods, which allows them to work as mixins.

Vaadin Flow uses the mixin concept to provide common APIs and default behavior for sets of functionalities found in most Web Components.

The most important predefined mixins are provided by the [interfacename]`HasSize`, [interfacename]`HasComponents` and [interfacename]`HasStyle` interfaces.
You can use these interfaces to add typical functions to your Java components.

== HasSize Interface

If your component implements the [interfacename]`HasSize` interface, you can set the size of the component using the [methodname]`setWidth(String)` and [methodname]`setHeight(String)` methods.

Extends [interfacename]`HasElement` mixin.

Methods available in the [interfacename]`HasSize` interface:

* [methodname]`void setWidth(String width)`
* [methodname]`void setWidth(float width, Unit unit)`
* [methodname]`void setMinWidth(String minWidth)`
* [methodname]`void setMinWidth(float minWidth, Unit unit)`
* [methodname]`void setMaxWidth(String maxWidth)`
* [methodname]`void setMaxWidth(float maxWidth, Unit unit)`
* [methodname]`String getWidth()`
* [methodname]`String getMinWidth()`
* [methodname]`String getMaxWidth()`
* [methodname]`Optional<Unit> getWidthUnit()`
* [methodname]`void setHeight(String height)`
* [methodname]`void setHeight(float height, Unit unit)`
* [methodname]`void setMinHeight(String minHeight)`
* [methodname]`void setMinHeight(float minHeight, Unit unit)`
* [methodname]`void setMaxHeight(String maxHeight)`
* [methodname]`void setMaxHeight(float maxHeight, Unit unit)`
* [methodname]`String getHeight()`
* [methodname]`String getMinHeight()`
* [methodname]`String getMaxHeight()`
* [methodname]`Optional<Unit> getHeightUnit()`
* [methodname]`void setSizeFull()`
* [methodname]`void setWidthFull()`
* [methodname]`void setHeightFull()`
* [methodname]`void setSizeUndefined()`

== HasComponents Interface

If your component implements the [interfacename]`HasComponents` interface, you can add and remove child components to and from it.

Extends [interfacename]`HasElement` and [interfacename]`HasEnabled` mixins.

It should generally be implemented by layouts or components whose primary
function is to host child components. It shouldn't be for example implemented
by non-layout components such as fields.

Methods available in the [interfacename]`HasComponents` interface:

* [methodname]`void add(Component... components)`
* [methodname]`void add(Collection<Component> components)`
* [methodname]`void add(String text)`
* [methodname]`void remove(Component... components)`
* [methodname]`void remove(Collection<Component> components)`
* [methodname]`void removeAll()`
* [methodname]`void addComponentAtIndex(int index, Component component)`
* [methodname]`void addComponentAsFirst(Component component)`

== HasStyle Interface

[interfacename]`HasStyle` interface adds a class attribute and support inline styles.
It's implemented in [classname]`Component` by default.

Extends [interfacename]`HasElement` mixin.

Methods available in the [interfacename]`HasStyle` interface:

* [methodname]`void addClassName(String className)`
* [methodname]`boolean removeClassName(String className)`
* [methodname]`void setClassName(String className)`
* [methodname]`String getClassName()`
* [methodname]`ClassList getClassNames()`
* [methodname]`void setClassName(String className, boolean set)`
* [methodname]`boolean hasClassName(String className)`
* [methodname]`Style getStyle()`
* [methodname]`void addClassNames(String... classNames)`
* [methodname]`void removeClassNames(String... classNames)`

== Using Mixin Interfaces

*Example*: Creating a custom `Tooltip` component that implements the [interfacename]`HasComponents` and [interfacename]`HasStyle` interfaces.

.Tooltip.java
[source,java]
----
@Tag("sample-tooltip")
@JsModule("./sample-tooltip.ts")
public class Tooltip extends LitTemplate
        implements HasComponents, HasStyle {

}
----

.sample-tooltip.ts
[source,javascript]
----
import { html, LitElement } from 'lit';

class SampleTooltip extends LitTemplate {
  render() {
    return html`
      <div part="content" theme="dark">
        <slot></slot>
      </div>
    `;
  }
}

customElements.define('sample-tooltip', SampleTooltip);
----

* A component that implements [interfacename]`HasComponents` needs to extend from a tag that supports having child components.
The `slot` tag is used in Web Components to define where child components should be put.

When you implement the [interfacename]`HasComponents` interface, adding child components to the parent component is allowed automatically.

*Example*: Adding new `H5` and `Paragraph` child components to the `Tooltip` parent component.

[source,java]
----
Tooltip tooltip = new Tooltip();

tooltip.add(new H5("Tooltip"));
tooltip.add(new Paragraph("I am a paragraph"));
----

== Other Useful Mixin Interfaces

Vaadin Flow provides many additional useful mixin interfaces. [interfacename]`HasElement` is low level API that is extended by most other mixins.

* [interfacename]`HasElement`: Marker interface for any class that's based on an [classname]`Element`.

Following list has mixins depending directly on a root element. All extends [interfacename]`HasElement`:

* [interfacename]`HasArialLabel`: For components and other UI objects that may have an aria-label and an aria-labelledby DOM attributes to set the accessible name of the component.
* [interfacename]`HasEnabled`: For components and other UI objects that can be enabled or disabled.
* [interfacename]`HasHelper`: For field components that have helper text as property and slots for inserting components.
* [interfacename]`HasLabel`: For components that supports label definition.
* [interfacename]`HasOrderedComponents`: Supports ordered child components, with an index for the layout.
* [interfacename]`HasText`: For components that supports text content.
* [interfacename]`HasTheme`: For components that have a theme DOM attribute.
* [interfacename]`HasValueAndElement`: Same as [interfacename]`HasValue` and also extends [interfacename]`HasElement` and [interfacename]`HasEnabled`.
* [interfacename]`Focusable<T>`: Provides methods to gain and lose focus.

Following mixins are for more generic use without direct dependency to any root element:

* [interfacename]`HasItems`: For components that display a collection of items.
* [interfacename]`HasDataProvider<T>`: For listing components that use a data provider to display data. Extends also [interfacename]`HasItems`.
* [interfacename]`HasValidation`: For components that supports input validation.
* [interfacename]`HasValue`: For field components and other UI objects that have a user-editable value.

== Advantages of Using Mixin Interfaces

Using Vaadin mixins is a best practice, because their code and functionality has been thoroughly checked and tested by Vaadin.

Mixins also keep your code clean and simple.
For example, compare setting component width:

* Without mixins: [methodname]`getElement().getStyle().set("width", "300px")`.
* After implementing the [interfacename]`HasSize` interface: [methodname]`setWidth("300px")`.


[discussion-id]`7E2169AD-5503-46B1-B044-6043B5C8BB4B`
